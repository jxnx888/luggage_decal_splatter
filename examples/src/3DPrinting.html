<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - interactive - voxel painter</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link rel="stylesheet" type="text/css" href="../css/dialog.css"/>
	<link type="text/css" rel="stylesheet" href="../css/font/iconfont.css">
	<link type="text/css" rel="stylesheet" href="../css/3dPrinting.css">
</head>
<body>
<div class="main_wrapper">
	<div id="container" class="clearfix"></div>
	<div class="show_more clearfix"><img src="../img/arrow.png" alt=""></div>
	<div id="shapes" class="clearfix">
		<div class="shapes_wrapper">
			<div class="shapes_options normal" onclick="showModule(0)">基础模型 <i class="iconfont arrow arrow_right">&#xe6f8;</i>
			</div>
			<div class="shapes_options cartoon" onclick="showModule(1)">卡通模型 <i class="iconfont arrow arrow_right">&#xe6f8;</i>
			</div>
			<div class="shapes_options cartoon" onclick="showModule(2)">我的模型 <i class="iconfont arrow arrow_right">&#xe6f8;</i>
			</div>
			<div class="shapes_options cartoon" onclick="showModule(3)">购买模型 <i class="iconfont arrow arrow_right">&#xe6f8;</i>
			</div>
		</div>
		<div class="child_wrapper normal_wrapper"></div>
		<div class="child_wrapper cartoon_wrapper"></div>
		<div class="child_wrapper ldraw_wrapper"></div>
		<div class="child_wrapper vpd_wrapper"></div>
	</div>
	<div class="obj_control has_right_menu">
		<div class="obj_control_wrapper clearfix">
			<div class="control_btn undo_control noActive_control" onclick="redoUndo(0)">
				<i class="iconfont">&#xe696;</i>
				<div class="btn_name">撤回</div>
			</div>
			<div class="control_btn redo_control noActive_control" onclick="redoUndo(1)">
				<i class="iconfont">&#xe697;</i>
				<div class="btn_name">恢复</div>
			</div>
			<div class="control_btn size_control" onclick="changeControls(0,this)">
				<div class="icon_wrapper">
				<i class="iconfont">&#xe6aa;</i>
				</div>
				<div class="btn_name">修改大小</div>
			</div>
			<div class="control_btn trans_control active_control" onclick="changeControls(1,this)">
				<div class="icon_wrapper">
				<i class="iconfont">&#xe69b;</i>
				</div>
				<div class="btn_name">选中</div>
			</div>
			<div class="control_btn rotate_control" onclick="changeControls(2,this)">
				<div class="icon_wrapper">
				<i class="iconfont">&#xe626;</i>
				</div>
				<div class="btn_name">旋转</div>
			</div>
			<div class="control_btn zoomin_control" onclick="cameraSides(7)">
				<i class="iconfont">&#xe691;</i>
				<div class="btn_name">放大</div>
			</div>
			<div class="control_btn zoomout_control" onclick="cameraSides(8)">
				<i class="iconfont">&#xe632;</i>
				<div class="btn_name">缩小</div>
			</div>
			<div class="control_btn delete_control" onclick="deletedSelected()">
				<i class="iconfont">&#xe783;</i>
				<div class="btn_name">删除</div>
			</div>
			<div class="control_btn iconfont color_control yellow_control" onclick="changeCurrentColor(1)"><div class="color_circle"></div></div>
			<div class="control_btn iconfont color_control white_control" onclick="changeCurrentColor(0)"><div class="color_circle"></div></div>
		</div>
		<!--<div class="zoom_control">
			<div class="iconfont" onclick="cameraSides(7)">&#xe611;</div>
			<div class="zoom_index">100%</div>
			<div class="iconfont" onclick="cameraSides(8)">&#xe626;</div>
		</div>-->
	</div>

	<div class="side_control">
		<div class="side_control_btn iconfont" onclick="showCameraSides()">&#xe627;</div>
		<div class="sides_wrapper">
			<div class="side_control_btn iconfont " onclick="cameraSides('reset')">Reset</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(6)">45°</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(0)">正面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(1)">背面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(2)">左面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(3)">右面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(4)">上面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(5)">下面</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(7)">ZoomIn</div>
			<div class="side_control_btn iconfont " onclick="cameraSides(8)">ZoomOut</div>
		</div>
	</div>
	<div class="save_control">
		<div class="save_stl iconfont noActive_save" onclick="exportGLTF()">&#xe780;</div>
	</div>
	<div class="module_btns clearfix">
		<div class="btn_main go_mainPage">
			<div class="btn_child btn_home"><i class="iconfont">&#xe651;</i></div>
		</div>
		<div class="btn_main save_module">
			<div class="btn_child btn_save_module"><i class="iconfont">&#xe710;</i></div>
		</div>
	</div>
	<div class="note">
		<div class="select_module">选择一个模型，点击 箭头按 <span class="red">X</span>,<span class="green">Y</span>,<span class="blue">Z</span>单向缩 放,点击中心方块或 者双指，进行整体 缩放</div>
	</div>
</div>
<div id="info" style="display: none;">
	<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel
</div>
<div id="loading_data"><img src="../img/loading.gif" alt=""></div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.3/jquery.lazyload.min.js'></script>
<script src='../js/three.js'></script>
<script src='../js/STLLoader.js'></script>
<script src='../js/DecalGeometry.js'></script>
<script src='../js/OrbitControls.js'></script>
<script src='../js/dat.gui.min.js'></script>
<script src='../js/STLExporter.js'></script>
<script src='../js/DragControls.js'></script>
<script src='../js/TransformControls.js'></script>
<script src='../js/GLTFExporter.js'></script>
<script src='../js/LDrawLoader.js'></script>
<script src='../js/MMDLoader.js'></script>
<script src='../js/MMDAnimationHelper.js'></script>
<script src='../js/dialog.js'></script>
<script>
	$( ".show_more" ).click( function () {
		$( "#shapes" ).toggle();
		$( "#shapes" ).toggleClass( "shapes_close" );
		$( ".show_more" ).toggleClass( "show_more_close" );
		$( ".obj_control" ).toggleClass( "has_right_menu" );
		if($( ".obj_control" ).hasClass("has_right_menu")){
			$( ".obj_control" ).css({width:window.innerWidth-100});
		}
		else{
			$( ".obj_control" ).css({width:"100%"});
		}
		onWindowResize(); //canvas floats to right side,in case the show_more close, there were dark side
	} );

	function showModule( type ) {//type 0: 标准模型    1:卡通模型 2: lego 模型
		if (type == 0) {
			$( ".normal_wrapper" ).show();
		} else if (type == 1) {
			$( ".cartoon_wrapper" ).show();
		} else if (type == 2) {
			$( ".ldraw_wrapper" ).show();
		} else if (type == 3) {
			$( ".vpd_wrapper" ).show();
		}
	}

	function hideModule( obj ) {
		stopPropagationFn();
		$( obj ).parents( ".child_wrapper" ).hide();
	}

	listModule();
	var listShapes = [];
	var listLDraw = [];
	var listSTL = [];

	function listModule( type ) {
		$.ajax( {
			type: "GET",
			url: "../static/moduleList.json",
			dataType: "JSON",
			cache: false,
			beforeSend: function () {
			},
			success: function ( res ) {
				var shapesHtml = '<div class="child_title" onclick="hideModule(this)"><i class="iconfont arrow">&#xe720;</i>基础模型</div>';
				var shapesIndex = 0;
				listShapes = res.data.shapes;
				for (var i in listShapes) {
					shapesHtml += '<div class="module shapes drag ' + listShapes[i].title + '" onclick="changeShapes(' + listShapes[i].code + ',this)">';
					shapesHtml += '<img src="' + listShapes[i].url + '" alt="Doughnut" class="drag">';
					shapesHtml += '<div class="name drag">' + listShapes[i].name + '</div>';
					shapesHtml += '<div class="color_change">';
					shapesHtml += '<div class="color_option color_yellow color_circle" onclick="changeColorBeforeShoot(1,this)"></div>';
					shapesHtml += '<div class="color_option color_white color_circle" onclick="changeColorBeforeShoot(0,this)"></div>';
					shapesHtml += '</div>';
					shapesHtml += '</div>';
					shapesIndex ++;
				}
				$( ".normal_wrapper" ).html( shapesHtml );

				var cartoonHtml = '<div class="child_title" onclick="hideModule(this)"><i class="iconfont arrow">&#xe720;</i>卡通模型</div>';
				var cartoonIndex = 0;
				listSTL = res.data.stl;
				for (var i in listSTL) {
					cartoonHtml += '<div class="module lego drag ' + listSTL[i].title + '" onclick="loadSTL(' + cartoonIndex + ',this)">';
					cartoonHtml += '<img src="../img/3dPrinting/doughnut.png" alt="Doughnut" class="drag">';
					cartoonHtml += '<div class="name drag">' + listSTL[i].name + '</div>';
					cartoonHtml += '</div>';
					cartoonIndex ++;
				}
				$( ".cartoon_wrapper" ).html( cartoonHtml );


				var legoHtml = '<div class="child_title" onclick="hideModule(this)"><i class="iconfont arrow">&#xe720;</i>Lego</div>';
				var index = 0;
				listLDraw = res.data.lego;
				for (var i in listLDraw) {
					legoHtml += '<div class="module lego ' + listLDraw[i].name + '" onclick="askDialog(0,' + index + ')">';
					legoHtml += '<img src="../img/3dPrinting/doughnut.png" alt="Doughnut">';
					legoHtml += '<div class="name">' + listLDraw[i].name + '</div>';
					legoHtml += '</div>';
					index ++;
				}
				$( ".ldraw_wrapper" ).html( legoHtml );

			},
			error: function ( res ) {
				console.log( res );
			}
		} );

	}

	var dragObj;
	var selectedDragObj;
	var maxW, maxH;
	var shapesEventL = document.getElementById( "shapes" );
	var dragedFlag = false;
	shapesEventL.addEventListener( "touchstart", function ( e ) {
		selectedDragObj = $( e.target );
		if (selectedDragObj.hasClass( "drag" )) {
			if (selectedDragObj[0].tagName == "DIV") {
				dragObj = $( selectedDragObj ).parents( ".module" ).find( "img" ).clone();
			} else {
				dragObj = selectedDragObj.clone();
			}

			dragObj.addClass( "startDrag" );
			maxW = document.body.clientWidth - selectedDragObj[0].offsetWidth;
			maxH = document.body.clientHeight - selectedDragObj[0].offsetHeight;
			var ev = e || window.event;
			var touch = ev.targetTouches[0];
		}
	},false );
	shapesEventL.addEventListener( "touchmove", function ( e ) {
		dragedFlag = true;
		var ev = e || window.event;
		var touch = ev.targetTouches[0];
		var windowWidth = window.innerWidth;
		var movedDir = windowWidth - touch.clientX;
		if (dragObj && movedDir > 100) {
			$( "body" ).append( dragObj );
			var oLeft = touch.clientX - 50;
			var oTop = touch.clientY - 50;
			if (oLeft < 0) {
				oLeft = 0;
			} else if (oLeft >= maxW) {
				oLeft = maxW;
			}
			if (oTop < 0) {
				oTop;
			} else if (oTop >= maxH) {
				oTop = maxH;
			}
			dragObj[0].style.left = oLeft + 'px';
			dragObj[0].style.top = oTop + 'px';
		}
	},false );
	shapesEventL.addEventListener( "touchend", function ( e ) {
		if (dragObj && dragedFlag) {
			$( selectedDragObj ).parents( ".module" ).trigger( "click" );
			$( dragObj ).remove();
			onDocumentMouseDown( e );
		}
		dragedFlag = false;
	},false );
</script>
<script>

	var mobile = /Android|webOS|iPhone|iPad|BlackBerry/i.test( navigator.userAgent );
	var container = document.getElementById( 'container' ); //
	var camera, scene, renderer;
	var cameraZoom = 1;
	var plane;
	var gridHelper,gradGroundMesh,gradGroundMesh1;
	var mouse, raycaster, isShiftDown = false;
	var controls;
	var mouseHelper, mouseHelperMaterial;
	var cubeGeo, cubeMaterial;
	var controlsMoved = false;
	var objects = [];
	var currentObj; //当前形状
	var currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
	var currentShapeType;
	var currentColor;
	var currentColorFlag = 0;
	var currentObjMesh; //当前obj mesh
	var shapeHelperObjects = [];
	var shapesObj = []; //所有的当前已放置的obj
	var currentAllObjs = []; //所有的当前已放置的obj
	var transformControl;
	var transformControlModeType = 1;
	var transformControlMove = false;
	var focusedTransfromObj;
	var intersectsSelect = [];
	var intersection = {
		intersects: false,
		point: new THREE.Vector3(),
		normal: new THREE.Vector3()
	};
	var allOperation = [];//all the operated operation(undo)
	var redoOperation = [];//all the redo operation
	var undoArr = [];
	var redoArr = [];

	var shootedFlag = false;
	var params = {  //params for GUI
		SUBMIT: function () {
			if (objects.length > 1) {
				exportASCII();
			}
		},
		SUBMITGLTFE: function () {
			if (objects.length > 1) {
				exportGLTF();
			}
		},
		Geometry: 0,//选中的形状
		Cube: function () {
			changeShapes( 0 );
		},
		Cylinder: function () {
			changeShapes( 1 );
		},
		Cone: function () {
			changeShapes( 2 );
		},
		Ball: function () {
			changeShapes( 3 );
		},
		Doughnut: function () {
			changeShapes( 4 );
		},
		Standing: function () {
			loadSTL( 0 );
		},
		Climbing: function () {
			loadSTL( 1 );
		},
		Lying: function () {
			loadSTL( 2 );
		},
		Sitting: function () {
			loadSTL( 3 );
		},
		TyrannosaurusRex: function () {
			loadSTL( 4 );
		},

		color: 0,
		selectShape: false,
		changeCurrentSize: false,
		RoteShape: false,
		removeLast: function () {
			redoUndo();
		},
		clear: function () {
			removeAllShapes();
		},
	};
	var colorsObj = {
		White: 0,
		Yellow: 1
	};

	//LDraw
	var lDrawModul;
	var lDrawModulGUI;
	var progressBarDiv;
	var lDrawGuiData = {
		smoothNormals: true,
		separateObjects: true,
		constructionStep: 0,
		noConstructionSteps: "无步骤"
	};
	//LDraw  end
	var currentModule = 0; //0:基础模型 1：lego

	init();
	render();

	function init() {
		renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
		// renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setPixelRatio( ( window.devicePixelRatio ) ? window.devicePixelRatio : 1 );
		renderer.setSize( window.innerWidth, window.innerHeight );
		renderer.autoClear = false;
		renderer.setClearColor( 0x000000, 0.0 );
		container.appendChild( renderer.domElement );

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		// camera.position.set( 0, 200, 350 ); //正面
		camera.position.set( 290, 200, 280 ); //45°
		camera.lookAt( 0, 0, 0 );

		scene = new THREE.Scene();
		// scene.background = new THREE.Color( 0xf0f0f0 );
		// scene.background = new THREE.Color( 0xf8f8f9 );
		// scene.background = new THREE.Color( 0x000000 );

		// roll-over helpers

		var rollOverGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
		mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
		mouseHelper = new THREE.Mesh( rollOverGeo, mouseHelperMaterial );
		if (! mobile) {
			scene.add( mouseHelper );
		}
		// cubes

		cubeGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
		cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c } );

		// grid

		gridHelper = new THREE.GridHelper( 300, 30, 0xcecaca, 0xcecaca );
		gridHelper.name = 'GridHelper';
		scene.add( gridHelper );

		gradGroundMesh = new THREE.Mesh( new THREE.BoxBufferGeometry( 300, 300, .5 ), new THREE.MeshLambertMaterial( { color: 0xffffff } ) );
		gradGroundMesh.rotateOnAxis( new THREE.Vector3( 1, 0, 0 ), 90 * ( Math.PI / 180 ) );
		gradGroundMesh.position.y=-.5;
		gradGroundMesh.name = 'GridHelper';
		scene.add( gradGroundMesh );
		gradGroundMesh1 = new THREE.Mesh( new THREE.BoxBufferGeometry( 300, 300, 2 ), new THREE.MeshLambertMaterial( { color: 0xffc869 } ) );
		gradGroundMesh1.rotateOnAxis( new THREE.Vector3( 1, 0, 0 ), 90 * ( Math.PI / 180 ) );
		gradGroundMesh1.position.y=-2;
		gradGroundMesh1.name = 'GridHelper';
		scene.add( gradGroundMesh1 );

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		var geometry = new THREE.PlaneBufferGeometry( 300, 300 );
		geometry.rotateX( - Math.PI / 2 );

		plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
		plane.name = "plane";
		scene.add( plane );

		objects.push( plane );

		// lights

		var ambientLight = new THREE.AmbientLight( 0x606060 ); //0x606060
		scene.add( ambientLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
		// dirLightHeper = new THREE.DirectionalLightHelper( directionalLight, 115 );//光源辅助线
		// scene.add( dirLightHeper );
		scene.add( directionalLight );

		// 旋转控制
		controls = new THREE.OrbitControls( camera, renderer.domElement ); // project controller
		controls.minDistance = 10; //设置相机距离原点的最近距离 min distance of camera to coordinate origin
		controls.maxDistance = 1300;//设置相机距离原点的最远距离 max distance of camera to coordinate origin
		controls.enableKeys = true;
		controls.keys = {
			LEFT: 65, //left arrow
			UP: 87, // up arrow
			RIGHT: 68, // right arrow
			BOTTOM: 83 // down arrow
		};
		controls.addEventListener( 'change', function ( event ) {
			controlsMoved = true;
			if(objects.length>1) {
				if (camera.position.y < 0) { //当镜头在底板 底部后，隐藏
					clearCache(gridHelper);
					scene.remove( gridHelper );
					clearCache(gradGroundMesh);
					scene.remove( gradGroundMesh );
					clearCache(gradGroundMesh1);
					scene.remove( gradGroundMesh1 );
				} else {
					clearCache(gridHelper);
					scene.remove( gridHelper );
					clearCache(gradGroundMesh);
					scene.remove( gradGroundMesh );
					clearCache(gradGroundMesh1);
					scene.remove( gradGroundMesh1 );
					scene.add( gridHelper );
					scene.add( gradGroundMesh );
					scene.add( gradGroundMesh1 );
				}
			}
		} );
		// controls.enabled = false;
		//移动shape
		transformControl = new THREE.TransformControls( camera, renderer.domElement );
		transformControl.name = "transformControl";
		transformControl.size = 2;
		scene.add( transformControl );
		// transformControl.addEventListener( 'change', render );

		transformControl.addEventListener( 'dragging-changed', function ( event ) {
			if (controls) {
				controls.enabled = ! event.value;
			}
		} );
		transformControl.addEventListener( 'change', function () {
			if (shootedFlag) {
				shapesController( 0 );
			}
			transformControlMove = true;
		} );
		transformControl.addEventListener( 'mouseDown', function () {
			transformControlMove = false;
		} );
		transformControl.addEventListener( 'mouseUp', function () {
			if (transformControlMove) {
				allOperationAdd();
			}
		} );
		//移动shape End

		container.addEventListener( 'mousemove', onDocumentMouseMove, false );
		container.addEventListener( 'touchmove', function () {
			transformControlMove = true;
		} );
		container.addEventListener( 'touchmove', onDocumentMouseMove );
		container.addEventListener( 'mousedown', function ( e ) {
			controlsMoved = false;
		}, false );
		container.addEventListener( 'touchstart', function ( e ) {
			controlsMoved = false;
		}, false );
		container.addEventListener( 'mouseup', function ( e ) {
			if (transformControl.object) {
				focusedTransfromObj = transformControl.object;
			}
			if (currentModule == 0 && ! controlsMoved) {
				onDocumentMouseDown( e );
			}
		} );
		container.addEventListener( 'touchend', function ( e ) {
			if (transformControl.object) {
				focusedTransfromObj = transformControl.object;
			}
			if (currentModule == 0 && ! controlsMoved) {
				onDocumentMouseDown( e );
			}
		} );
		container.addEventListener( 'keydown', onDocumentKeyDown, false );
		container.addEventListener( 'keyup', onDocumentKeyUp, false );

		//
		// initGUI();
		container.addEventListener( 'resize', onWindowResize, false );
		window.addEventListener( 'resize', onWindowResize, false );
		animate();
		onWindowResize();
	}

	function animate() {
		requestAnimationFrame( animate );
		renderer.render( scene, camera );
		// stats.update();
	}

	function onWindowResize() {
		var controlBoardWidth = $( "#shapes" ).hasClass( "shapes_close" ); //left decal side width
		if (controlBoardWidth) {
			camera.aspect = ( window.innerWidth ) / window.innerHeight;
			renderer.setSize( window.innerWidth, window.innerHeight );
		} else {
			camera.aspect = ( window.innerWidth - 100 ) / window.innerHeight;
			renderer.setSize( window.innerWidth - 100, window.innerHeight );
		}
		camera.updateProjectionMatrix();

	}

	function onDocumentMouseMove( event ) {

		// event.preventDefault();

		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( objects );

		if (intersects.length > 0) {

			var intersect = intersects[0];

			mouseHelper.position.copy( intersect.point ).add( intersect.face.normal );
			mouseHelper.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

		}
		render();

	}

	function onDocumentMouseDown( event ) {
		if (! shootedFlag) {
			event.preventDefault();
			var controlBoardWidth = $( "#shapes" ).hasClass( "shapes_close" ); //left decal side width
			if (controlBoardWidth) {
				if (event.type == "touchend") {
					var touch = event.changedTouches[0];
					mouse.set( ( touch.clientX / window.innerWidth ) * 2 - 1, - ( touch.clientY / window.innerHeight ) * 2 + 1 );
				} else {
					mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
				}
			} else {
				if (event.type == "touchend") {
					var touch = event.changedTouches[0];
					mouse.set( ( touch.clientX / ( window.innerWidth - 100 ) ) * 2 - 1, - ( touch.clientY / window.innerHeight ) * 2 + 1 );
				} else {
					mouse.set( ( event.clientX / ( window.innerWidth - 100 ) ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
				}
			}
			/*	mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );
                if(event.type == "touchend"){
                    var touch = event.changedTouches[ 0 ];
                    mouse.set( ( touch.clientX / window.innerWidth ) * 2 - 1, - ( touch.clientY / window.innerHeight ) * 2 + 1 );
                }*/

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( objects );

			if (intersects.length > 0) {

				var intersect = intersects[0];

				// delete cube

				if (isShiftDown) {

					if (intersect.object !== plane) {

						scene.remove( intersect.object );

						objects.splice( objects.indexOf( intersect.object ), 1 );

					}

					// create cube

				} else {
					if (objects.length < 11 && currentObj) {
						var voxelMaterial = currentObjMaterial.clone();
						var voxel = new THREE.Mesh( currentObj, voxelMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						voxel.name = "shapes";
						scene.add( voxel );
						objects.push( voxel );
						shapeHelperObjects.push( voxel );
						shapesObj.push( voxel ); //全删除使用
						currentAllObjs.push( voxel ); //
						$( ".undo_control" ).removeClass( "noActive_control" );//
						$( ".save_stl" ).removeClass( "noActive_save" );//
						transformControl.object = voxel;
						focusedTransfromObj = transformControl.object;
						var obj = {};
						obj['uuid'] = focusedTransfromObj.uuid;
						obj['position'] = focusedTransfromObj.position.clone();
						allOperation.push( obj );
						if ($( ".obj_control_wrapper" ).css( "display" ) == 'block') { //if the transformControl active, so change to new object
							transformControl.attach( focusedTransfromObj );
						}
						resetSomeThing();
					}
					/*else {
						console.log( "The max shapes are 10." );
					}*/
				}
				shootedFlag = true;
				// OrbitControlsFn();
				render();

			}
		} else {
			checkIntersection();
		}
	}
	function resetSomeThing(){
		$(".active_shape").removeClass("active_shape");
		currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xdddddd } );
	}
	function onDocumentKeyDown( event ) {

		switch (event.keyCode) {

			case 16:
				isShiftDown = true;
				break;

		}

	}

	function onDocumentKeyUp( event ) {

		switch (event.keyCode) {

			case 16:
				isShiftDown = false;
				break;

		}

	}

	function render() {

		renderer.render( scene, camera );

	}

	/**
	 * 清空当前obj对象的缓存
	 * @param mesh  mesh对象
	 * */
	function clearCache( currentMesh ) {
		currentMesh.geometry.dispose();
		currentMesh.material.dispose();
	}

	function initGUI() {

		var gui = new dat.GUI();
		gui.close();

		/*gui.add( params, 'SUBMIT' );
		gui.add( params, 'Geometry', geometries ).onChange( function () {
			// changeShapes(geometries[ params.Geometry ]);
			changeShapes();
		} );
		gui.add( params, 'color', shapeColor ).name('Color').onChange( function () {
			changeCurrentColor(shapeColor[params.color]);
		} );*/
		var shapess = gui.addFolder( "Shapes" );
		shapess.add( params, 'Cube' );
		shapess.add( params, 'Cylinder' );
		shapess.add( params, 'Cone' );
		shapess.add( params, 'Ball' );
		shapess.add( params, 'Doughnut' );
		shapess.add( params, 'Standing' );
		shapess.add( params, 'Climbing' );
		shapess.add( params, 'Lying' );
		shapess.add( params, 'Sitting' );
		shapess.add( params, 'TyrannosaurusRex' );
		shapess.open();

		gui.add( params, 'color', colorsObj ).name( "Color" ).onChange( function () {
			changeCurrentColor();
		} );

		/*var colorss = gui.addFolder("Color");
		colorss.add(params,'white');
		colorss.add(params,'yellow');
		colorss.open();*/
		gui.add( params, 'selectShape' ).onChange( function () {
			selectShapeModule();
		} );
		gui.add( params, 'changeCurrentSize' ).onChange( function () {
			if (params.changeCurrentSize) {
				transformControl.setMode( "scale" );
			} else {
				transformControl.setMode( "translate" );
			}
		} );
		gui.add( params, 'RoteShape' ).onChange( function () {
			if (params.RoteShape) {
				transformControl.setMode( "rotate" );
			} else {
				transformControl.setMode( "translate" );
			}
		} );

		gui.add( params, 'removeLast' ).name( "Remove Last Shape" );
		gui.add( params, 'clear' ).name( "Remove All" );
		gui.add( params, 'SUBMIT' ).name( "exportSTL" );
		gui.add( params, 'SUBMITGLTFE' ).name( "exportGLTF" );
		/*	var navGUI = new dat.GUI();
            var side = navGUI.addFolder("Sides");
            side.add(navParams,'front').name("Front");
            side.add(navParams,'back').name("Back");
            side.add(navParams,'left').name("Left");
            side.add(navParams,'right').name("Right");
            side.add(navParams,'top').name("Top");
            side.add(navParams,'bottom').name("Bottom");
            side.add(navParams,'reset').name("Reset");
            side.close();*/

		$( ".dg.ac .dg.main.a" ).addClass( "main_menu" );
		$( ".dg.ac .dg.main.a ul:eq(0)" ).addClass( "menu_ul_main" );
		$( ".dg.ac .dg.main.a ul:eq(1)" ).addClass( "menu_ul_shapes" );
		$( ".menu_ul_main li:eq(1)" ).addClass( "asdf" );

	}

	function changeShapes( geo ) {//geo: 当前类型
		stopPropagationFn();
		$(".active_color").removeClass("active_color");
		currentModule = 0;//编辑模式，各种基础模型
		enabledLego( 1 );
		shootedFlag = false;
		/*if(controls){
			controls.dispose();
		}*/
		$( ".active_shape" ).removeClass( "active_shape" );
		switch (geo) {
			case 0:
				// 正方形
				currentShapeType = 0;
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
				$( ".cube" ).addClass( "active_shape" );
				break;
			case 1:
				//圆柱
				currentShapeType = 1;
				currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 32 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
				$( ".cylinder" ).addClass( "active_shape" );
				break;
			case 2:
				// 圆锥形
				currentShapeType = 2;
				currentObj = new THREE.ConeBufferGeometry( 25, 50, 32 ); //ConeBufferGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
				$( ".cone" ).addClass( "active_shape" );
				break;
			case 3:
				// 球形
				currentShapeType = 3;
				currentObj = new THREE.SphereBufferGeometry( 25, 25, 32 );//SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
				$( ".ball" ).addClass( "active_shape" );
				break;
			case 4:
				// 环形
				currentShapeType = 4;
				currentObj = new THREE.TorusGeometry( 20, 5, 16, 100 );//TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)
				$( ".doughnut" ).addClass( "active_shape" );
				break;
			case 5:
				// 棱柱形prismatic
				currentShapeType = 14;
				currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 5 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
				$( ".prismatic" ).addClass( "active_shape" );
				break;
			case 6:
				// 棱锥形Pyramid
				currentShapeType = 15;
				currentObj = new THREE.ConeBufferGeometry( 25, 50, 4 ); //ConeBufferGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
				$( ".pyramid" ).addClass( "active_shape" );
				break;
			case 7:
				// 空心圆柱Hollow cylinder
				currentShapeType = 16;
				var outerRadius = 25;
				var innerRadius = 13;
				var height = 50;

				var arcShape = new THREE.Shape();
				arcShape.moveTo(outerRadius * 2, outerRadius);
				arcShape.absarc(outerRadius, outerRadius, outerRadius, 0, Math.PI * 2, false);
				var holePath = new THREE.Path();
				holePath.moveTo(outerRadius + innerRadius, outerRadius);
				holePath.absarc(outerRadius, outerRadius, innerRadius, 0, Math.PI * 2, true);
				arcShape.holes.push(holePath);
				var geometry = new THREE.ExtrudeGeometry(arcShape, {
					amount: height,
					bevelEnabled: false,
					steps: 1,
					curveSegments: 60
				});
				geometry.center();
				geometry.rotateX(Math.PI * -.5);
				currentObj = geometry;//TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)
				$( ".hollowcylinder" ).addClass( "active_shape" );
				break;
			case 8:
				// 三棱柱
				currentShapeType = 17;
				currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 3 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
				$( ".triprism" ).addClass( "active_shape" );
				break;
			default:
				// 正方形
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
		}

		changeMouseHelper( currentColorFlag );
		currentObjMesh = new THREE.Mesh( currentObj, currentObjMaterial );
		// scene.add( currentObjMesh );
	}
	function changeColorBeforeShoot(type,obj){
		stopPropagationFn();
		$(".active_color").removeClass("active_color");
		if(type==0){
			$(obj).addClass('active_color');
			currentObjMaterial =  new THREE.MeshLambertMaterial( { color: 0xdddddd } );
		}
		else if(type==1){
			$(obj).addClass('active_color');
			currentObjMaterial =  new THREE.MeshLambertMaterial( { color: 0xf2f545 } );
		}
	}
	function changeCurrentColor( type ) {
		if(transformControl.object) {
			if (type == 0) {
				transformControl.object.material.color.set( "#dddddd" );
			} else {
				transformControl.object.material.color.set( "#f2f545" );
			}
		}
	}

	function changeMouseHelper( type ) { //type 0: 颜色改为白色 1：颜色改为黄色
		if (type == 0) {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 1, transparent: true } );
		} else {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xf2f545, opacity: 1, transparent: true } );
		}
		clearCache( mouseHelper );
		scene.remove( mouseHelper );
		mouseHelper = new THREE.Mesh( currentObj, mouseHelperMaterial );
		mouseHelper.name = "mouseHelper";
		if (! mobile) {
			scene.add( mouseHelper );
		}
	}

	function selectShapeModule() {
		if (shootedFlag) {
			console.log( "remove" );
			clearCache( mouseHelper );
			scene.remove( mouseHelper );
			camera.position.set( 150, 200, 300 );
			camera.lookAt( 0, 0, 0 );
			render();
		} else {
			transformControl.detach( transformControl.object ); //隐藏控制控件
			selectedShapeFlag = false;
			camera.position.set( 0, 200, 350 );
			camera.lookAt( 0, 0, 0 );
			render();
			if (! mobile) {
				scene.add( mouseHelper );
			}
		}
	}

	function removeAllShapes() {
		shapesObj.forEach( function ( d ) {
			clearCache( d );
			scene.remove( d );
			for (var i in objects) {
				if (objects[i].uuid == d.uuid) {
					objects.splice( i, 1 ); //remove element that index is i in array decals
				}
			}
		} );
		shapesObj = [];
		transformControl.detach(); //隐藏控制控件
	}

	function redoUndo( type ) { //type 0: undo 1: redo
		if (type == 0) {
			if (objects.length > 1) {
				scene.remove( objects[objects.length - 1] );
				redoArr.push( objects[objects.length - 1] );
				objects.pop();
			}
		} else {
			if (redoArr.length > 0) {
				scene.add( redoArr[0] );
				objects.push( redoArr[0] );
				redoArr.shift();
			}
		}
		transformControl.detach(); //隐藏控制控件
		if (objects.length > 1) {
			$( ".undo_control" ).removeClass( "noActive_control" );
		} else {
			$( ".undo_control" ).addClass( "noActive_control" );
		}
		if (redoArr.length > 0) {
			$( ".redo_control" ).removeClass( "noActive_control" );
		} else {
			$( ".redo_control" ).addClass( "noActive_control" );
		}

	}

	function redoUndo1( type ) { //type 0: undo 1: redo
		if (allOperation.length > 1 && type == 0 && focusedTransfromObj) {
			var obj = allOperation[allOperation.length - 1];
			redoOperation.push( obj ); //add the undo to redo
			for (var i = allOperation.length - 1; i > - 1; i --) {
				if (transformControl.object.uuid == allOperation[i].uuid) {
					transformControl.object.position.copy( allOperation[i].position );
					break;
				}
			}
			if (allOperation.length > 1) {
				transformControl.object.position.copy( allOperation[allOperation.length - 2].position );
			}
			allOperation.pop();
		} else if (allOperation.length == 1 && objects.length == 2) {
			transformControl.detach( transformControl.object ); //隐藏控制控件
			scene.remove( objects[1] );
			scene.remove( objects[1] );
			objects.pop();
			allOperation.pop();
		} else if (redoOperation.length > 0 && type == 1) {
			if (objects.length != 0) {
				var obj = redoOperation[redoOperation.length - 1];
				allOperation.push( obj ); //add the redo to undo
				for (var i = redoOperation.length - 1; i > - 1; i --) {
					if (transformControl.object) {
						if (transformControl.object.uuid == redoOperation[i].uuid) {
							transformControl.object.position.copy( redoOperation[i].position );
							break;
						}
					} else {
						for (var i = currentAllObjs.length - 1; i > - 1; i --) {
							if (redoOperation[i].uuid == currentAllObjs[i].uuid) {
								scene.add( currentAllObjs[i] );
								objects.push( currentAllObjs[i] );
							}
						}
					}
				}
				allOperation.pop();
			} else {
				for (var i = currentAllObjs.length - 1; i > - 1; i --) {
					scene.add( currentAllObjs[i] );
					objects.push( currentAllObjs[i] );
				}

			}
		}
		render();
		if (allOperation.length > 0) {
			$( ".undo_control" ).removeClass( "noActive_control" );
		} else {
			$( ".undo_control" ).addClass( "noActive_control" );
		}
		if (redoOperation.length > 0) {
			$( ".redo_control" ).removeClass( "noActive_control" );
		} else {
			$( ".redo_control" ).addClass( "noActive_control" );
		}

	}

	function checkIntersection() {
		var x, y;

		if (event.changedTouches) {

			x = event.changedTouches[0].pageX;
			y = event.changedTouches[0].pageY;

		} else {

			x = event.clientX;
			y = event.clientY;

		}

		mouse.x = ( x / window.innerWidth ) * 2 - 1;
		mouse.y = - ( y / window.innerHeight ) * 2 + 1;

		if (! plane) return;
		raycaster.setFromCamera( mouse, camera );
		raycaster.intersectObject( plane, false, intersectsSelect );
		if (intersectsSelect.length > 0) {

			var p = intersectsSelect[0].point;
			mouseHelper.position.set( 0, 0, 0 );
			mouseHelper.position.copy( p );  //copy intersection position to mouseHelper
			intersection.point.copy( p );
			/*1.克隆旧的法线 2.旧法线乘以模型的世界矩阵得到归一化后的法线 3.和一个标量相乘，放大10倍。 4.加上点击点的坐标，进行平移。*/
			var n = intersectsSelect[0].face.normal.clone();
			n.transformDirection( plane.matrixWorld );
			n.multiplyScalar( 10 );
			n.add( intersectsSelect[0].point );

			intersection.normal.copy( intersectsSelect[0].face.normal );
			mouseHelper.lookAt( n );

			var sceneChilds = raycaster.intersectObjects( scene.children ); //get all objects in the current position of your mouse;
			if (sceneChilds.length > 1) {
				if (sceneChilds && sceneChilds[0].object.name == "shapes") {
					transformControl.detach( transformControl.object );
					transformControl.attach( sceneChilds[0].object );
				} else if (sceneChilds[0].object.name == "plane") {
					transformControl.detach( transformControl.object );
					transformControl.attach( sceneChilds[0].object );
				}
			}
			intersection.intersects = true;
			intersectsSelect.length = 0;

		} else {
			intersection.intersects = false;
			transformControl.detach( transformControl.object );
			focusedShape = null;
		}
		render();
	}

	// transform controller 用于pc端
	var hiding;

	function delayHideTransform() {
		cancelHideTransform();
		hideTransform();
	}

	function hideTransform() {
		hiding = setTimeout( function () {
			transformControl.detach( transformControl.object );
		}, 2500 );
	}

	function cancelHideTransform() {
		if (hiding) clearTimeout( hiding );
	}

	function updateShapePosition() {
		console.log( "updateShapePosition" );
	}

	// transform controller 用于pc端

	// 导出相关
	function exportASCII() {
		if (objects.length > 1) {
			scene.remove( transformControl );
			scene.remove( gridHelper );
			scene.remove( mouseHelper );
			clearCache(gridHelper);
			scene.remove( gridHelper );
			clearCache(gradGroundMesh);
			scene.remove( gradGroundMesh );
			clearCache(gradGroundMesh1);
			scene.remove( gradGroundMesh1 );

			exporter = new THREE.STLExporter(); //导出工具  exporter tool
			var result = exporter.parse( scene );
			var date = Date.parse( new Date() );
			saveString( result, date + '.stl' );

			scene.add( transformControl );
			scene.add( gridHelper );
			scene.add( gridHelper );
			scene.add( gradGroundMesh );
			scene.add( gradGroundMesh1 );
			if (! mobile) {
				scene.add( mouseHelper );
			}
		}
	}

	function save( blob, filename ) {
		var link = document.createElement( 'a' );
		link.style.display = 'none';
		link.className = 'saveFile';
		document.body.appendChild( link );
		link.href = URL.createObjectURL( blob );
		link.download = filename;
		link.click();
		$( ".saveFile" ).remove();

	}

	function saveString( text, filename ) {
		// console.log( new Blob( [ text ]))
		save( new Blob( [text], { type: 'text/plain' } ), filename );

	}

	function exportGLTF() {
		if (objects.length > 1) {
			scene.remove( transformControl );
			scene.remove( gridHelper );
			scene.remove( mouseHelper );

			var input = scene;
			var gltfExporter = new THREE.GLTFExporter();

			var options = {
				trs: false,
				onlyVisible: true,
				truncateDrawRange: true,
				binary: false,
				forcePowerOfTwoTextures: false,
				maxTextureSize: 4096
			};
			gltfExporter.parse( input, function ( result ) {
				var output = JSON.stringify( result, null, 2 );
				console.log( output );
				var date = Date.parse( new Date() );
				saveString( output, date + '.gltf' );
			}, options );
			scene.add( transformControl );
			scene.add( gridHelper );
			if (! mobile) {
				scene.add( mouseHelper );
			}
		}
	}

	// 导出相关 end
	//camera 方向
	function showCameraSides() {
		$( ".sides_wrapper" ).toggle();
	}

	function cameraSides( type ) {
		// stopPropagationFn();
		switch (type) {
			case 0: //front
				toOrthographicCamera( 0 );
				camera.position.set( 0, 0, 350 );
				break;
			case 1://rear
				toOrthographicCamera( 0 );
				camera.position.set( 0, 0, - 350 );
				break;
			case 2://left
				toOrthographicCamera( 0 );
				camera.position.set( - 350, 0, 0 );
				break;
			case 3://right
				toOrthographicCamera( 0 );
				camera.position.set( 350, 0, 0 );
				break;
			case 4://top
				toOrthographicCamera( 1 );
				camera.position.set( 0, 450, 0 );
				break;
			case 5://bottom
				toOrthographicCamera( 1 );
				camera.position.set( 0, - 450, 0 );
				break;
			case 6://45°角度
				toOrthographicCamera( 1 );
				camera.position.set( 290, 200, 280 );
				break;
			case 7://zoom in
				if (cameraZoom) {
					cameraZoom = cameraZoom + 0.1;
					camera.zoom = cameraZoom;
					var zoomHtml = ( cameraZoom * 100 ).toFixed( 0 ) + "%";
					$( ".zoom_index" ).text( zoomHtml );
				}
				break;
			case 8://zoom out
				cameraZoom = cameraZoom - 0.1;
				camera.zoom = cameraZoom;
				var zoomHtml = ( cameraZoom * 100 ).toFixed( 0 ) + "%";
				$( ".zoom_index" ).text( zoomHtml );
				break;
			default://reset
				camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
				camera.position.set( 0, 200, 350 );
		}
		camera.lookAt( scene.position );
		camera.updateProjectionMatrix();
		if (type != 7 && type != 8) {
			resetZoom();
		}
		// controls.update();
		// controls.dispose();
	}

	function toOrthographicCamera( type ) {
		var aspect = window.innerWidth / window.innerHeight;
		if (type == 0) {
			var frustumSize = 200;
		} else {
			var frustumSize = 350;
		}
		camera = new THREE.OrthographicCamera( frustumSize * aspect / - 2, frustumSize * aspect / 2, frustumSize / 2, frustumSize / - 2, 1, 1000 );
	}

	//camera 方向
	function resetZoom() {
		$( ".zoom_index" ).text( "100%" );
		camera.zoom = 1;
		camera.lookAt( scene.position );
		camera.updateProjectionMatrix();
	}

	function loadSTL( thisSTL, obj ) {
		$( ".active_shape" ).removeClass( "active_shape" );
		$( obj ).addClass( "active_shape" );
		currentModule = 0; //编辑模式，各种基础模型
		enabledLego( 1 );
		$( "#loading_data" ).show();
		shootedFlag = false;
		/*if(controls){
			controls.dispose();
		}*/
		var file;
		switch (thisSTL) {
			case 0:
				file = '../models/stl/ascii/standing.stl';
				currentShapeType = 5;
				break;
			case 1:
				file = '../models/stl/ascii/climbing.stl';
				currentShapeType = 6;
				break;
			case 2:
				file = '../models/stl/ascii/lying.stl';
				currentShapeType = 7;
				break;
			case 3:
				file = '../models/stl/ascii/sitting.stl';
				currentShapeType = 8;
				break;
			case 4:
				file = '../models/stl/ascii/tyrannosaurusRex.stl';
				currentShapeType = 8;
				break;
			case 5:
				file = '../models/stl/ascii/pokemon/bulbasaur_starter_1gen_flowalistik.stl';
				currentShapeType = 9;
				break;
			case 6:
				file = '../models/stl/ascii/pokemon/charmander_starter_1gen_flowalistik.stl';
				currentShapeType = 9;
				break;
			case 7:
				file = '../models/stl/ascii/pokemon/chikorita_starter_2gen_flowalistik.stl';
				currentShapeType = 10;
				break;
			case 8:
				file = '../models/stl/ascii/pokemon/pikachu_1gen_flowalistik.stl';
				currentShapeType = 11;
				break;
			case 9:
				file = '../models/stl/ascii/pokemon/squirtle_starter_1gen_flowalistik.stl';
				currentShapeType = 12;
				break;
			case 10:
				file = '../models/stl/ascii/pokemon/totodile_starter_2gen_flowalistik.stl';
				currentShapeType = 13;
				break;
			default:
				file = '../models/stl/ascii/tyrannosaurusRex.stl';
		}
		var loader = new THREE.STLLoader();
		loader.load( file, function ( geometry ) {
			currentObj = geometry;
			$( "#loading_data" ).hide();
		} );
	}

	//Lego
	function askDialog( type, index ) {
		if (currentModule == 0) {
			var text = '';
			if (type == 0) {
				text = '<p class="removeFont">You will lost your design if you open the Lego</p>';
			} else if (type == 1) {
				text = '<p class="removeFont">You will lost your design if you open the pose</p>';
			}
			$.dialog( {
				type: 'confirm',
				showTitle: false,
				overlayClose: true,
				dialogClass: 'removeSingleBox',
				showClose: true,
				contentHtml: text,
				buttonText: {
					ok: 'Confirm',
					cancel: 'Cancel'
				},
				buttonClass: {
					ok: 'removeBtn_ok',
					cancel: 'removeBtn_cancel'
				},
				onClickOk: function () {
					resetZoom();
					if (type == 0) {
						currentModule = 1; //lego模式
						loadLDraw( index );
					} else if (type == 1) {
						currentModule = 2; //pose模式
						loadVpd( index );
					} else {
						currentModule = 0;
					}

				},
				onClickCancel: function () {

				}
			} );
		} else {
			loadLDraw( index );
		}
	}

	function loadLDraw( thisLDraw ) {
		$( "#loading_data" ).show();
		enabledLego( 0 );
		var currentLDraw;
		switch (thisLDraw) {
			case 0:
				currentLDraw = listLDraw[0].url;
				break;
			case 1:
				currentLDraw = listLDraw[1].url;
				break;
			case 2:
				currentLDraw = listLDraw[2].url;
				break;
			case 3:
				currentLDraw = listLDraw[3].url;
				break;
			case 4:
				currentLDraw = listLDraw[4].url;
				break;
			case 5:
				currentLDraw = listLDraw[5].url;
				break;
			case 6:
				currentLDraw = listLDraw[6].url;
				break;
		}
		if (lDrawModul) {
			scene.remove( lDrawModul );
		}

		lDrawModul = null;

		var lDrawLoader = new THREE.LDrawLoader();
		lDrawLoader.separateObjects = lDrawGuiData.separateObjects;
		lDrawLoader.smoothNormals = lDrawGuiData.smoothNormals;
		lDrawLoader
			.load( currentLDraw, function ( group2 ) {

				if (lDrawModul) {

					scene.remove( lDrawModul );

				}

				lDrawModul = group2;

				// Convert from LDraw coordinates: rotate 180 degrees around OX
				lDrawModul.rotation.x = Math.PI;

				scene.add( lDrawModul );

				// Adjust materials

				var lDrawMaterials = lDrawLoader.materials;

				lDrawGuiData.constructionStep = lDrawModul.userData.numConstructionSteps - 1;

				updateObjectsVisibility();

				// Adjust camera and light

				var bbox = new THREE.Box3().setFromObject( lDrawModul );
				var size = bbox.getSize( new THREE.Vector3() );
				var radius = Math.max( size.x, Math.max( size.y, size.z ) ) * 0.5;

				if (false) {
					controls.target0.copy( bbox.getCenter( new THREE.Vector3() ) );
					controls.position0.set( - 2.3, 2, 2 ).multiplyScalar( radius ).add( controls.target0 );
					controls.reset();
				}
				createGUI();
				$( "#loading_data" ).hide();
			} );

	}

	function updateObjectsVisibility() {

		lDrawModul.traverse( c => {
			if (c.isLineSegments) {
			} else if (c.isGroup) {
				// Hide objects with construction step > gui setting
				c.visible = c.userData.constructionStep <= lDrawGuiData.constructionStep;
			}
		} );
	}

	function createGUI() {
		if (lDrawModulGUI) {
			lDrawModulGUI.destroy();
			$( ".lego_constrution" ).hide();
		}
		lDrawModulGUI = new dat.GUI();
		if (lDrawGuiData.separateObjects) {
			if (lDrawModul.userData.numConstructionSteps > 1) {
				lDrawModulGUI.add( lDrawGuiData, 'constructionStep', 0, lDrawModul.userData.numConstructionSteps - 1 ).step( 1 ).name( '建模步骤' ).onChange( updateObjectsVisibility );//Construction step
			} else {
				lDrawModulGUI.add( lDrawGuiData, 'noConstructionSteps' ).name( '建模步骤' ).onChange( updateObjectsVisibility );
			}
		}

		$( ".dg.ac" ).addClass( "lego_constrution" );
		$( ".dg.ac.lego_constrution" ).find( "ul li" );
		$( ".dg.ac" ).show();

	}

	function enabledLego( type ) { //type 0:enable 1:disable
		if (type == 0) {
			removeAllShapes(); //删除所有目标
			// $(".side_control").hide(); //
			shapesController( 0 );//不显示所有控制
			// scene.background = new THREE.Color( 0xdeebed );
			clearCache( gridHelper );
			scene.remove( gridHelper );
		} else {
			scene.remove( lDrawModul );
			if (lDrawModulGUI) {
				lDrawModulGUI.destroy();
				lDrawModulGUI = '';
				$( ".lego_constrution" ).hide();
			}
			// scene.background = new THREE.Color( 0x000000 );
			// $(".side_control").show();
			scene.add( gridHelper );
		}
	}

	//Lego end
	function OrbitControlsFn( type ) { //type=controls.enabled  0 true 1 false

		if (type === 0) {
			controls.enabled = true;
		} else {
			controls.enabled = false;
		}
		// 旋转控制end
		// }
	}

	function changeControls( type, obj ) {
		if (transformControlModeType == 0 && type == 0) {
			$( obj ).toggleClass( "active_control" );
		} else if (transformControlModeType == 1 && type == 1) {
			$( obj ).toggleClass( "active_control" );
		} else if (transformControlModeType == 2 && type == 2) {
			$( obj ).toggleClass( "active_control" );
		} else if (transformControlModeType == 3 && type == 3) {
			$( obj ).toggleClass( "active_control" );
		} else {
			$( ".active_control" ).removeClass( "active_control" );
			$( obj ).addClass( "active_control" );
		}
		if (! $( obj ).hasClass( "active_control" )) {
			transformControl.detach( transformControl.object ); //隐藏控制控件
		} else {
			transformControl.attach( transformControl.object ); //隐藏控制控件
		}
		switch (type) {
			case 0:
				transformControl.setMode( "scale" );
				transformControlModeType = 0;
				break;
			case 1:
				transformControl.setMode( "translate" );
				transformControlModeType = 1;
				break;
			case 2:
				transformControl.setMode( "rotate" );
				transformControlModeType = 2;
				break;
			default:
				transformControl.setMode( "translate" );
				transformControlModeType = 0;
		}
	}

	function deletedSelected() {
		if (focusedTransfromObj) {
			allOperation.push( focusedTransfromObj ); //add to opeartion arr
			scene.remove( focusedTransfromObj );
			objects.splice( objects.indexOf( focusedTransfromObj ), 1 );
		}
		transformControl.detach();
		// $(".active_control").removeClass("active_control");
		shapesController( 0 );
		render();
	}

	function shapesController( type ) {//type 0: normal
		if (type == 0) {
			if (objects.length > 1) { //objects has obj plane
				if(!$(".show_more").hasClass("show_more_close")){
					$(".obj_control").css({width:window.innerWidth-100})
				}
				$( ".obj_control_wrapper,.note" ).show();

			} else if (redoArr.length < 1) {
				$( ".obj_control_wrapper" ).hide();
			}
			if (allOperation.length > 0) {

			}
		} else {
			$( ".obj_control_wrapper" ).hide();
		}
	}

	function allOperationAdd() {
		if (focusedTransfromObj) {
			var obj = {};
			obj['uuid'] = focusedTransfromObj.uuid;
			obj['position'] = focusedTransfromObj.position.clone();
			allOperation.push( obj ); //add to opeartion arr
			console.log( "added: " + obj );
		}
		if (allOperation.length > 0) {
			$( ".undo_control" ).removeClass( "noActive_control" );
		} else {
			$( ".undo_control" ).addClass( "noActive_control" );
		}
	}

	function stopPropagationFn() {
		var e = event || window.event || arguments.callee.caller.arguments[0];
		if (e && e.stopPropagation) {
			e.stopPropagation();
		} else { //ie
			window.event.cancelBubble = true;
		}

	}
</script>

</body>
</html>
