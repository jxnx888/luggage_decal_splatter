<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - interactive - voxel painter</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<!--	<link type="text/css" rel="stylesheet" href="../css/main.css">-->
	<link type="text/css" rel="stylesheet" href="../css/font/iconfont.css">
	<link type="text/css" rel="stylesheet" href="../css/3dPrinting.css">
</head>
<body>
<div class="main_wrapper">
	<div id="container"></div>
	<div id="shapes">
		<div class="shapes_wrapper">
			<div class="shapes_options normal">标准模型 <i class="iconfont arrow arrow_right">&#xe6a3;</i></div>
			<div class="shapes_options person">任务模型 <i class="iconfont arrow arrow_right">&#xe6a3;</i></div>
			<div class="shapes_options cartoon">卡通模型 <i class="iconfont arrow arrow_right">&#xe6a3;</i></div>
		</div>
		<div class="child_wrapper normal_wrapper">
			<div class="child_title"><i class="iconfont arrow">&#xe6a5;</i> 标准模型</div>
			<div class="module shapes cube" onclick="changeShapes(0)">
				<img src="../img/3dPrinting/cube.png" alt="Cube">
				<div class="name">正方形</div>
			</div>
			<div class="module shapes cylinder" onclick="changeShapes(1)">
				<img src="../img/3dPrinting/cylinder.png" alt="Cylinder">
				<div class="name">圆柱形</div>
			</div>
			<div class="module shapes cone" onclick="changeShapes(2)">
				<img src="../img/3dPrinting/cone.png" alt="Cone">
				<div class="name">圆锥形</div>
			</div>
			<div class="module shapes ball" onclick="changeShapes(3)">
				<img src="../img/3dPrinting/ball.png" alt="Ball">
				<div class="name">球形</div>
			</div>
			<div class="module shapes doughnut" onclick="changeShapes(4)">
				<img src="../img/3dPrinting/doughnut.png" alt="Doughnut">
				<div class="name">环形</div>
			</div>
		</div>
	</div>
	<div class="obj_control">
		<div class="obj_control_wrapper clearfix">
			<div class="control_btn iconfont size_control" onclick="changeControls(0,this)">&#xe725;</div>
			<div class="control_btn iconfont trans_control active_control" onclick="changeControls(1,this)">&#xe648;</div>
			<div class="control_btn iconfont rotate_control" onclick="changeControls(2,this)">&#xe6e2;</div>
		</div>
	</div>
</div>
<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - voxel painter - webgl<br>
	<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel
</div>
<div id="loading_data"><img src="../img/loading.gif" alt=""></div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.3/jquery.lazyload.min.js'></script>
<script src='../js/three.js'></script>
<script src='../js/STLLoader.js'></script>
<script src='../js/DecalGeometry.js'></script>
<script src='../js/OrbitControls.js'></script>
<script src='../js/dat.gui.min.js'></script>
<script src='../js/STLExporter.js'></script>
<script src='../js/DragControls.js'></script>
<script src='../js/TransformControls.js'></script>
<script src='../js/GLTFExporter.js'></script>
<script>
	$(".normal").click(function(){
		stopProp();
		$(".normal_wrapper").show();
	})
	$(".child_title").click(function(){
		stopProp();
		$(".normal_wrapper").hide();
	})
	function stopProp(){
		var e = event || window.event || arguments.callee.caller.arguments[0];
		if ( e && e.stopPropagation ){
			e.stopPropagation();
		}else{ //ie
			window.event.cancelBubble = true;
		}

	}
</script>
<script>
	var mobile=/Android|webOS|iPhone|iPad|BlackBerry/i.test(navigator.userAgent);
	var container = document.getElementById( 'container' ); //
	var camera, scene, renderer;
	var plane;
	var mouse, raycaster, isShiftDown = false;
	var controls;
	var mouseHelper, mouseHelperMaterial;
	var cubeGeo, cubeMaterial;

	var objects = [];
	var currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 ); //当前形状
	var currentObjMaterial;
	var currentShapeType;
	var currentColor;
	var currentColorFlag = 0;
	var currentObjMesh; //当前obj mesh
	var shapeHelperObjects = [];
	var shapesObj = []; //所有的当前已放置的obj
	var transformControl;
	var intersectsSelect = [];
	var intersection = {
		intersects: false,
		point: new THREE.Vector3(),
		normal: new THREE.Vector3()
	};
	var shootedFlag = false;
	var params = {  //params for GUI
		SUBMIT:function (){
			if(objects.length>1) {
				exportASCII();
			}
		},
		SUBMITGLTFE:function (){
			if(objects.length>1) {
				exportGLTF();
			}
		},
		Geometry:0,//选中的形状
		Cube:function(){
			changeShapes(0);
		},
		Cylinder:function(){
			changeShapes(1);
		},
		Cone:function(){
			changeShapes(2);
		},
		Ball:function(){
			changeShapes(3);
		},
		Doughnut:function(){
			changeShapes(4);
		},
		Standing:function(){
			loadSTL(0);
		},
		Climbing:function(){
			loadSTL(1);
		},
		Lying:function(){
			loadSTL(2);
		},
		Sitting:function(){
			loadSTL(3);
		},
		TyrannosaurusRex:function(){
			loadSTL(4);
		},

		color:0,
		selectShape:false,
		changeCurrentSize:false,
		RoteShape:false,
		removeLast:function(){
			removeLastShape();
		},
		clear:function(){
			removeAllShapes();
		},
	};
	var colorsObj = {
		White:0,
		Yellow:1
	}
	var navParams = {
		front:function(){
			cameraSides(0);
		},
		back:function(){
			cameraSides(1);
		},
		left:function(){
			cameraSides(2);
		},
		right:function(){
			cameraSides(3);
		},
		top:function(){
			cameraSides(4);
		},
		bottom:function(){
			cameraSides(5);
		},
		reset:function(){
			cameraSides(6);
		},
	}

	init();
	render();

	function init() {

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 0, 200, 350 );
		camera.lookAt( 0, 0, 0 );

		scene = new THREE.Scene();
		// scene.background = new THREE.Color( 0xf0f0f0 );
		scene.background = new THREE.Color( 0xf8f8f9 );

		// roll-over helpers

		var rollOverGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
		mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000, opacity: 0.5, transparent: true } );
		mouseHelper = new THREE.Mesh( rollOverGeo, mouseHelperMaterial );
		if(!mobile) {
			scene.add( mouseHelper );
		}
		// cubes

		cubeGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
		cubeMaterial = new THREE.MeshLambertMaterial( { color: 0xfeb74c} );

		// grid

		var gridHelper = new THREE.GridHelper( 300, 6, 0x79c2de,0x79c2de);
		// var gridHelper = new THREE.GridHelper( 300, 30, 0xbde5f3,0x79c2de);
		scene.add( gridHelper );

		//

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		var geometry = new THREE.PlaneBufferGeometry( 300, 300 );
		geometry.rotateX( - Math.PI / 2 );

		plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
		plane.name="plane";
		scene.add( plane );

		objects.push( plane );

		// lights

		var ambientLight = new THREE.AmbientLight( 0x606060 );
		scene.add( ambientLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
		scene.add( directionalLight );

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		container.appendChild( renderer.domElement );


		//移动shape
		transformControl = new THREE.TransformControls( camera, renderer.domElement );
		transformControl.name="transformControl"
		scene.add( transformControl );
		// transformControl.addEventListener( 'change', render );
		transformControl.addEventListener( 'dragging-changed', function ( event ) {
			if(controls) {
				controls.enabled = ! event.value;
			}
		} );
		transformControl.addEventListener( 'change', function () {
			if(shootedFlag) {
				$(".obj_control").show();
			}
		} );

		//移动shape End

		document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		window.addEventListener( 'touchmove', onDocumentMouseMove );
		document.addEventListener( 'mouseup', onDocumentMouseDown, false );
		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );

		//
		// initGUI();
		window.addEventListener( 'resize', onWindowResize, false );
		animate();
	}
	function animate() {
		requestAnimationFrame( animate );
		renderer.render( scene, camera );
		// stats.update();
	}
	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseMove( event ) {

		// event.preventDefault();

		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			var intersect = intersects[ 0 ];

			mouseHelper.position.copy( intersect.point ).add( intersect.face.normal );
			mouseHelper.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

		}
		render();

	}

	function onDocumentMouseDown( event ) {
		if(!shootedFlag) {
			event.preventDefault();

			mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

			raycaster.setFromCamera( mouse, camera );

			var intersects = raycaster.intersectObjects( objects );

			if (intersects.length > 0) {

				var intersect = intersects[0];

				// delete cube

				if (isShiftDown) {

					if (intersect.object !== plane) {

						scene.remove( intersect.object );

						objects.splice( objects.indexOf( intersect.object ), 1 );

					}

					// create cube

				} else {
					if (objects.length < 11) {
						var voxel = new THREE.Mesh( currentObj, currentObjMaterial );
						voxel.position.copy( intersect.point ).add( intersect.face.normal );
						voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
						voxel.name = "shapes";
						scene.add( voxel );
						objects.push( voxel );
						shapeHelperObjects.push( voxel );
						shapesObj.push( voxel );
					} else {
						console.log( "The max shapes are 10." )
					}
				}
				shootedFlag = true;
				// OrbitControlsFn();
				render();

			}
		}
		else{
			checkIntersection()
		}
	}

	function onDocumentKeyDown( event ) {

		switch ( event.keyCode ) {

			case 16: isShiftDown = true; break;

		}

	}

	function onDocumentKeyUp( event ) {

		switch ( event.keyCode ) {

			case 16: isShiftDown = false; break;

		}

	}
	function onTouchMove(event){

	}
	function render() {

		renderer.render( scene, camera );

	}
	/**
	 * 清空当前obj对象的缓存
	 * @param mesh  mesh对象
	 * */
	function clearCache(currentMesh) {
		currentMesh.geometry.dispose();
		currentMesh.material.dispose();
	}

	function initGUI(){

		var gui = new dat.GUI();
		gui.close();

		/*gui.add( params, 'SUBMIT' );
		gui.add( params, 'Geometry', geometries ).onChange( function () {
			// changeShapes(geometries[ params.Geometry ]);
			changeShapes();
		} );
		gui.add( params, 'color', shapeColor ).name('Color').onChange( function () {
			changeCurrentColor(shapeColor[params.color]);
		} );*/
		var shapess = gui.addFolder("Shapes");
		shapess.add(params,'Cube');
		shapess.add(params,'Cylinder');
		shapess.add(params,'Cone');
		shapess.add(params,'Ball');
		shapess.add(params,'Doughnut');
		shapess.add(params,'Standing');
		shapess.add(params,'Climbing');
		shapess.add(params,'Lying');
		shapess.add(params,'Sitting');
		shapess.add(params,'TyrannosaurusRex');
		shapess.open();

		gui.add( params, 'color', colorsObj ).name("Color").onChange(function(){
			changeCurrentColor()
		});

		/*var colorss = gui.addFolder("Color");
		colorss.add(params,'white');
		colorss.add(params,'yellow');
		colorss.open();*/
		gui.add(params,'selectShape').onChange(function(){
			selectShapeModule();
		});
		gui.add(params,'changeCurrentSize').onChange(function(){
			if(params.changeCurrentSize){
				transformControl.setMode( "scale" );
			}
			else {
				transformControl.setMode( "translate" );
			}
		});
		gui.add(params,'RoteShape').onChange(function(){
			if(params.RoteShape){
				transformControl.setMode( "rotate" );
			}
			else {
				transformControl.setMode( "translate" );
			}
		});

		gui.add(params,'removeLast').name("Remove Last Shape");
		gui.add(params,'clear').name("Remove All");
		gui.add( params, 'SUBMIT' ).name("exportSTL");
		gui.add( params, 'SUBMITGLTFE' ).name("exportGLTF");
	/*	var navGUI = new dat.GUI();
		var side = navGUI.addFolder("Sides");
		side.add(navParams,'front').name("Front");
		side.add(navParams,'back').name("Back");
		side.add(navParams,'left').name("Left");
		side.add(navParams,'right').name("Right");
		side.add(navParams,'top').name("Top");
		side.add(navParams,'bottom').name("Bottom");
		side.add(navParams,'reset').name("Reset");
		side.close();*/

		$(".dg.ac .dg.main.a").addClass("main_menu");
		$(".dg.ac .dg.main.a ul:eq(0)").addClass("menu_ul_main");
		$(".dg.ac .dg.main.a ul:eq(1)").addClass("menu_ul_shapes");
		$(".menu_ul_main li:eq(1)").addClass("asdf");

	}
	function changeShapes(geo){//geo: 当前类型
		shootedFlag = false;
		if(controls){
			controls.dispose();
		}
		$(".active_shape").removeClass("active_shape");
		switch (geo) {
			case 0:
				// 正方形
				currentShapeType = 0;
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
				$(".cube").addClass("active_shape");
				break;
			case 1:
				//圆柱
				currentShapeType = 1;
				currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 32 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
				$(".cylinder").addClass("active_shape");
				break;
			case 2:
				// 圆锥形
				currentShapeType = 2;
				currentObj = new THREE.ConeBufferGeometry( 25, 50, 32 ); //ConeBufferGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
				$(".cone").addClass("active_shape");
				break;
			case 3:
				// 球形
				currentShapeType = 3;
				currentObj =  new THREE.SphereBufferGeometry( 25, 25, 32);//SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
				$(".ball").addClass("active_shape");
				break;
			case 4:
				// 环形
				currentShapeType = 4;
				currentObj =  new THREE.TorusGeometry(20, 5, 16, 100 );//TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)
				$(".doughnut").addClass("active_shape");
				break;
			default:
				// 正方形
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
		}

		changeMouseHelper(currentColorFlag);
		currentObjMesh = new THREE.Mesh(currentObj,currentObjMaterial);
		// scene.add( currentObjMesh );
	}
	function changeCurrentColor(){
		var color =params.color;
		if(color == 0) {
			currentColor = 0xFFFFFF;
			currentColorFlag = 0;
			currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF } );
			changeMouseHelper(0)
		}
		else{
			currentColorFlag = 1;
			currentColor=0xf2f545
			currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xf2f545 } );
			changeMouseHelper(1)
		}
	}
	function changeMouseHelper(type){ //type 0: 颜色改为白色 1：颜色改为黄色
		if (type == 0) {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 1, transparent: true } );
		} else {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xf2f545, opacity: 1, transparent: true } );
		}
		clearCache( mouseHelper );
		scene.remove( mouseHelper );
		mouseHelper = new THREE.Mesh( currentObj, mouseHelperMaterial );
		mouseHelper.name = "mouseHelper";
		if(!mobile) {
			scene.add( mouseHelper );
		}
	}
	function selectShapeModule(){
		if(shootedFlag) {
			console.log( "remove" );
			clearCache( mouseHelper );
			scene.remove( mouseHelper );
			camera.position.set( 150, 200, 300 );
			camera.lookAt( 0, 0, 0 );
			render();
		}
		else{
			transformControl.detach( transformControl.object ); //隐藏控制控件
			selectedShapeFlag = false;
			camera.position.set( 0, 200, 350 );
			camera.lookAt( 0, 0, 0 );
			render();
			if(!mobile) {
				scene.add( mouseHelper );
			}
		}
	}
	function removeAllShapes(){
		shapesObj.forEach( function ( d ) {
			clearCache(d);
			scene.remove( d );
			for(var i in objects){
				if(objects[i].uuid == d.uuid) {
					objects.splice( i, 1 ); //remove element that index is i in array decals
				}
			}
		} );
		shapesObj = [];
	}
	function removeLastShape(){
		if (objects[objects.length - 1]) {
			clearCache( objects[objects.length - 1] );
			scene.remove( objects[objects.length - 1] );
			objects.pop();
		}
	}

	function checkIntersection(){
		var x, y;

		if ( event.changedTouches ) {

			x = event.changedTouches[ 0 ].pageX;
			y = event.changedTouches[ 0 ].pageY;

		} else {

			x = event.clientX;
			y = event.clientY;

		}

		mouse.x = ( x / window.innerWidth ) * 2 - 1;
		mouse.y = - ( y / window.innerHeight ) * 2 + 1;

		if (! plane) return;
		raycaster.setFromCamera( mouse, camera );
		raycaster.intersectObject( plane, false, intersectsSelect );
		if (intersectsSelect.length > 0) {

			var p = intersectsSelect[0].point;
			mouseHelper.position.set( 0, 0, 0 );
			mouseHelper.position.copy( p );  //copy intersection position to mouseHelper
			intersection.point.copy( p );
			/*1.克隆旧的法线 2.旧法线乘以模型的世界矩阵得到归一化后的法线 3.和一个标量相乘，放大10倍。 4.加上点击点的坐标，进行平移。*/
			var n = intersectsSelect[0].face.normal.clone();
			n.transformDirection( plane.matrixWorld );
			n.multiplyScalar( 10 );
			n.add( intersectsSelect[0].point );

			intersection.normal.copy( intersectsSelect[0].face.normal );
			mouseHelper.lookAt( n );

			var sceneChilds = raycaster.intersectObjects( scene.children ); //get all objects in the current position of your mouse;
			if(sceneChilds.length>1) {
				if (sceneChilds && sceneChilds[0].object.name == "shapes") {
					transformControl.detach( transformControl.object );
					transformControl.attach( sceneChilds[0].object );
				} else if (sceneChilds[0].object.name == "plane") {
					transformControl.detach( transformControl.object );
					transformControl.attach( sceneChilds[0].object );
				}
			}
			intersection.intersects = true;
			intersectsSelect.length = 0;

		} else {
			intersection.intersects = false;
			transformControl.detach( transformControl.object );
			focusedShape = null;
		}
		render();
	}

	// 移动shape
	var hiding;

	function delayHideTransform() {

		cancelHideTransform();
		hideTransform();

	}

	function hideTransform() {

		hiding = setTimeout( function () {

			transformControl.detach( transformControl.object );

		}, 2500 );

	}

	function cancelHideTransform() {

		if ( hiding ) clearTimeout( hiding );

	}
	function updateShapePosition() {

		console.log("updateShapePosition")
	}
	// 移动shape End

	// 导出相关
	function exportASCII() {
		scene.remove(transformControl);
		scene.remove(mouseHelper);
		exporter = new THREE.STLExporter(); //导出工具  exporter tool
		var result = exporter.parse( scene );
		var date= Date.parse(new Date());
		saveString( result, date+'.stl' );

		scene.add(transformControl);
		scene.add(mouseHelper);
	}
	var link = document.createElement( 'a' );
	link.style.display = 'none';
	document.body.appendChild( link );

	function save( blob, filename ) {

		link.href = URL.createObjectURL( blob );
		link.download = filename;
		link.click();

	}
	function saveString( text, filename ) {

		save( new Blob( [ text ], { type: 'text/plain' } ), filename );

	}
	function exportGLTF(  ) {
		scene.remove(transformControl);
		scene.remove(mouseHelper);
		var input = scene;
		var gltfExporter = new THREE.GLTFExporter();

		var options = {
			trs: false,
			onlyVisible: true,
			truncateDrawRange: true,
			binary: false,
			forcePowerOfTwoTextures: false,
			maxTextureSize: 4096
		};
		gltfExporter.parse( input, function ( result ) {
			var output = JSON.stringify( result, null, 2 );
			console.log( output );
			saveString( output, 'scene.gltf' );
		}, options );
		scene.add(transformControl);
		scene.add(mouseHelper);
	}
	// 导出相关 end
	//camera 方向
	function cameraSides(type){
		controls = new THREE.OrbitControls( camera, renderer.domElement ); // project controller
		camera.position.set( 0, 0, 1400 );
		switch (type) {
			case 0: //front
				break;
			case 1://rear
				break;
			case 2://left
				break;
			case 3://right
				break;
			case 4://top
				break;
			case 5://bottom
				break;
			default://reset
				camera.position.set( 500, 800, 1300 );
		}
		controls.update();
		controls.dispose();
	}
	//camera 方向


	function loadSTL(thisSTL){
		var file;
		switch (thisSTL) {
			case 0:
				file = '../models/stl/ascii/standing.stl';
				currentShapeType = 5;
				break;
			case 1:
				file = '../models/stl/ascii/climbing.stl';
				currentShapeType = 6;
				break;
			case 2:
				file = '../models/stl/ascii/lying.stl';
				currentShapeType = 7;
				break;
			case 3:
				file = '../models/stl/ascii/sitting.stl';
				currentShapeType = 8;
				break;
			default:
				file = '../models/stl/ascii/tyrannosaurusRex.stl';
		}
		$("#loading_data").show();
		var loader = new THREE.STLLoader();
		loader.load( file, function ( geometry ) {
			currentObj = geometry;
			$("#loading_data").hide();
		} );
	}

	function OrbitControlsFn(){

		if(shootedFlag) {
			// 旋转控制
			controls = new THREE.OrbitControls( camera, renderer.domElement ); // project controller
			controls.minDistance = 10; //设置相机距离原点的最近距离 min distance of camera to coordinate origin
			controls.maxDistance = 1300;//设置相机距离原点的最远距离 max distance of camera to coordinate origin
			controls.enableKeys = true;
			controls.keys = {
				LEFT: 65, //left arrow
				UP: 87, // up arrow
				RIGHT: 68, // right arrow
				BOTTOM: 83 // down arrow
			}
			// 旋转控制end
		}
	}
	function changeControls(type,obj) {
		var focusedObj = transformControl.object;
		switch (type) {
			case 0:
				transformControl.setMode( "scale" );
				break;
			case 1:
				transformControl.setMode( "translate" );
				break;
			case 2:
				transformControl.setMode( "rotate" );
				break;
			default:
				transformControl.setMode( "translate" );
		}
		// focusedObj.
		$(".active_con" +
			"trol").removeClass("active_control");
		$(obj).addClass("active_control");
	}
</script>

</body>
</html>
