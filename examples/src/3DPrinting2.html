<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl - interactive - voxel painter</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
	<link type="text/css" rel="stylesheet" href="../css/main.css">
</head>
<body>

<div id="info">
	<a href="https://threejs.org" target="_blank" rel="noopener">three.js</a> - voxel painter - webgl<br>
	<strong>click</strong>: add voxel, <strong>shift + click</strong>: remove voxel
</div>

<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.1/jquery.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/jquery_lazyload/1.9.3/jquery.lazyload.min.js'></script>
<script src='../js/three.js'></script>
<script src='../js/STLLoader.js'></script>
<script src='../js/DecalGeometry.js'></script>
<script src='../js/OrbitControls.js'></script>
<script src='../js/dat.gui.min.js'></script>
<script src='../js/STLExporter.js'></script>
<script src='../js/DragControls.js'></script>
<script src='../js/TransformControls.js'></script>
<script src='../js/GLTFExporter.js'></script>
<script>

	var camera, scene, renderer;
	var plane;
	var mouse, raycaster, isShiftDown = false;
	var moved = false;
	var mouseHelper, mouseHelperMaterial;
	var intersectsSelect = [];
	var intersection = {
		intersects: false,
		point: new THREE.Vector3(),
		normal: new THREE.Vector3()
	};
	var objects = [];

	var controls; // project controller
	var exporter; //文件导出
	var controlRotate;//current rotate control flag
	var objsColorMaterial; // 形状的颜色
	var currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 ); //当前形状
	var currentObjMaterial;
	var currentShapeType;
	var currentColor;
	var currentColorFlag = 0;
	var currentObjMesh; //当前obj mesh
	var currentScalar;
	var shapesObj = []; //所有的当前已放置的obj
	var params = {  //params for GUI
		SUBMIT:function (){
			if(objects.length>1) {
				exportASCII();
			}
		},
		SUBMITGLTFE:function (){
			if(objects.length>1) {
				exportGLTF();
			}
		},
		Geometry:0,//选中的形状
		Cube:function(){
		changeShapes(0);
		},
		Cylinder:function(){
			changeShapes(1);
		},
		Cone:function(){
			changeShapes(2);
		},
		Ball:function(){
			changeShapes(3);
		},
		Doughnut:function(){
			changeShapes(4);
		},
		color:0,
		white:function(){
			changeCurrentColor(0)
		},
		yellow:function(){
			changeCurrentColor(1)
		},
		selectShape:false,

		clear:function(){
			removeAllShapes();
		}
	};
	var geometries = { //形状参数
		Cube: 0,
		Cylinder:1,
		Cone: 2,
		Ball: 3,
		Doughnut: 4,
	};
	var shapeColor= { white:0, yellow:1}; //选择颜色参数
	var focusedShape;
	var focusedShapeINTERSECTED;
	var focusedShapes=[];
	var focusedShapeUUID;
	var selectedShapeFlag = false;// selected the shape

	var transformControl;
	var shapeHelperObjects = [];


	init();
	render();

	function init() {

		camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 10000 );
		camera.position.set( 500, 800, 1300 );
		camera.lookAt( 0, 0, 0 );

		scene = new THREE.Scene();
		scene.background = new THREE.Color( 0xf0f0f0 );

		// roll-over helpers
		//鼠标方块
		var rollOverGeo = new THREE.BoxBufferGeometry( 50, 50, 50 );
		mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 1, transparent: true } );
		mouseHelper = new THREE.Mesh( rollOverGeo, mouseHelperMaterial );
		mouseHelper.name="mouseHelper";
		scene.add( mouseHelper );

		// cubes

		currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
		currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF} );

		// grid
		//水平网格
		var gridHelper = new THREE.GridHelper( 1000, 20 );
		scene.add( gridHelper );
		//

		raycaster = new THREE.Raycaster();
		mouse = new THREE.Vector2();

		var geometry = new THREE.PlaneBufferGeometry( 1000, 1000 );
		geometry.rotateX( - Math.PI / 2 );

		plane = new THREE.Mesh( geometry, new THREE.MeshBasicMaterial( { visible: false } ) );
		plane.name="plane";
		scene.add( plane );

		objects.push( plane );

		// lights

		var ambientLight = new THREE.AmbientLight( 0x606060 );
		scene.add( ambientLight );

		var directionalLight = new THREE.DirectionalLight( 0xffffff );
		directionalLight.position.set( 1, 0.75, 0.5 ).normalize();
		scene.add( directionalLight );

		renderer = new THREE.WebGLRenderer( { antialias: true } );
		renderer.setPixelRatio( window.devicePixelRatio );
		renderer.setSize( window.innerWidth, window.innerHeight );
		document.body.appendChild( renderer.domElement );

		controls = new THREE.OrbitControls( camera, renderer.domElement ); // project controller
		controls.minDistance = 10; //设置相机距离原点的最近距离 min distance of camera to coordinate origin
		controls.maxDistance = 1300;//设置相机距离原点的最远距离 max distance of camera to coordinate origin


		transformControl = new THREE.TransformControls( camera, renderer.domElement );
		transformControl.addEventListener( 'change', render );
		transformControl.addEventListener( 'dragging-changed', function ( event ) {
			controls.enabled = ! event.value;
		} );
		scene.add( transformControl );
		// Hiding transform situation is a little in a mess :()
		transformControl.addEventListener( 'change', function () {
			if(params.selectShape) {
				cancelHideTransform();
			}
		} );

		transformControl.addEventListener( 'mouseDown', function () {
			if(params.selectShape) {
				cancelHideTransform();
			}
		} );

		transformControl.addEventListener( 'mouseUp', function () {
			if(params.selectShape) {
				delayHideTransform();
			}
		} );

		transformControl.addEventListener( 'objectChange', function () {
			if(params.selectShape) {
				updateShapePosition();
			}
		} );

		var dragcontrols = new THREE.DragControls( shapeHelperObjects, camera, renderer.domElement ); //
		dragcontrols.enabled = false;
		dragcontrols.addEventListener( 'drag',render);
		dragcontrols.addEventListener( 'hoveron', function ( event ) {
			if(params.selectShape) {
				transformControl.attach( event.object );
				cancelHideTransform();
			}
		} );

		dragcontrols.addEventListener( 'hoveroff', function () {
			delayHideTransform();
		} );


		document.addEventListener( 'mousedown',  function (e) {
			moved = false;
		});
		controls.addEventListener( 'change', function () {
			moved = true;
		} );
		document.addEventListener( 'mouseup', function (e) {
			if (e.button == 0) { //mouse left button
				if(!moved && !params.selectShape) {
					onDocumentMouseDown(e);
				}
				else if(params.selectShape){
					if(focusedShapeUUID){
						selectedShapeFlag = true;
					}
				}
			}
		})
		// document.addEventListener( 'mousemove', onDocumentMouseMove, false );
		document.addEventListener( 'mousemove', function(e){
			if(params.selectShape){
				controls.enableRotate = false; //disable the controls'Rotate
				controlRotate = false;
				// checkIntersection();
			}
			else{
				controls.enableRotate = true; //enable the controls'Rotate
				controlRotate = true;
				onDocumentMouseMove(e)
			}
		} );
		window.addEventListener( 'touchmove', onDocumentMouseMove, false );
		document.addEventListener( 'keydown', onDocumentKeyDown, false );
		document.addEventListener( 'keyup', onDocumentKeyUp, false );

		//
		initGUI();//all the control GUI
		window.addEventListener( 'resize', onWindowResize, false );

	}

	function onWindowResize() {

		camera.aspect = window.innerWidth / window.innerHeight;
		camera.updateProjectionMatrix();

		renderer.setSize( window.innerWidth, window.innerHeight );

	}

	function onDocumentMouseMove( event ) {

		event.preventDefault();

		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			var intersect = intersects[ 0 ];

			mouseHelper.position.copy( intersect.point ).add( intersect.face.normal );
			mouseHelper.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );

		}

		render();

	}

	function onDocumentMouseDown( event ) {

		event.preventDefault();

		mouse.set( ( event.clientX / window.innerWidth ) * 2 - 1, - ( event.clientY / window.innerHeight ) * 2 + 1 );

		raycaster.setFromCamera( mouse, camera );

		var intersects = raycaster.intersectObjects( objects );

		if ( intersects.length > 0 ) {

			var intersect = intersects[ 0 ];

			// delete cube

			if ( isShiftDown ) {

				if ( intersect.object !== plane ) {

					scene.remove( intersect.object );

					objects.splice( objects.indexOf( intersect.object ), 1 );

				}

				// create cube

			} else {
				if(objects.length< 11) {
					switch (currentShapeType) {
						case 0:
							// 正方形
							currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
							break;
						case 1:
							//圆柱
							currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 32 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
							break;
						case 2:
							// 圆锥形
							currentObj = new THREE.ConeBufferGeometry( 25, 50, 32 ); //ConeBufferGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
							break;
						case 3:
							// 球形
							currentObj =  new THREE.SphereBufferGeometry( 25, 25, 32);//SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
							break;
						case 4:
							// 环形
							currentObj =  new THREE.TorusGeometry(20, 5, 16, 100 );//TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)
							break;
						default:
							// 正方形
							currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
					}
					var voxel = new THREE.Mesh( currentObj, currentObjMaterial );
					voxel.position.copy( intersect.point ).add( intersect.face.normal );
					voxel.position.divideScalar( 50 ).floor().multiplyScalar( 50 ).addScalar( 25 );
					voxel.name="shapes";
					scene.add( voxel );
					objects.push( voxel );
					shapeHelperObjects.push( voxel );
					shapesObj.push( voxel );
				}
			}

			render();

		}

	}

	function onDocumentKeyDown( event ) {

		switch ( event.keyCode ) {

			case 16: isShiftDown = true; break;

		}

	}

	function onDocumentKeyUp( event ) {

		switch ( event.keyCode ) {

			case 16: isShiftDown = false; break;

		}

	}

	function render() {

		renderer.render( scene, camera );

	}
	function checkIntersection(){
		var x, y;

		if ( event.changedTouches ) {

			x = event.changedTouches[ 0 ].pageX;
			y = event.changedTouches[ 0 ].pageY;

		} else {

			x = event.clientX;
			y = event.clientY;

		}

		mouse.x = ( x / window.innerWidth ) * 2 - 1;
		mouse.y = - ( y / window.innerHeight ) * 2 + 1;

		if (! plane) return;
		raycaster.setFromCamera( mouse, camera );
		raycaster.intersectObject( plane, false, intersectsSelect );
		if (intersectsSelect.length > 0) {

			var p = intersectsSelect[0].point;
			mouseHelper.position.set( 0, 0, 0 );
			mouseHelper.position.copy( p );  //copy intersection position to mouseHelper
			intersection.point.copy( p );
			/*1.克隆旧的法线 2.旧法线乘以模型的世界矩阵得到归一化后的法线 3.和一个标量相乘，放大10倍。 4.加上点击点的坐标，进行平移。*/
			var n = intersectsSelect[0].face.normal.clone();
			n.transformDirection( plane.matrixWorld );
			n.multiplyScalar( 10 );
			n.add( intersectsSelect[0].point );

			intersection.normal.copy( intersectsSelect[0].face.normal );
			mouseHelper.lookAt( n );

			var sceneChilds = raycaster.intersectObjects( scene.children ); //get all objects in the current position of your mouse;
			if(sceneChilds.length>1) {
				if (sceneChilds && sceneChilds[0].object.name == "shapes" && focusedShape != sceneChilds[0].object) {
					if (focusedShape) {
						focusedShape.material.emissive.setHex( 0 );
					}
					focusedShape = sceneChilds[0].object;
					focusedShapeUUID = focusedShape.uuid;
					// focusedShape.currentHex = focusedShape.material.emissive.getHex();
					focusedShape.material.emissive.setHex( 0xf00000 );
				} else if (sceneChilds[0].object.name == "plane") {
					if (focusedShape) {
						focusedShape.material.emissive.setHex( 0 );
						focusedShape = null;
					}
				}
			}
			console.log(focusedShapeUUID)
			intersection.intersects = true;
			intersectsSelect.length = 0;

		} else {
			intersection.intersects = false;
			if(focusedShape&&focusedShapeUUID){
				focusedShape.material.emissive.setHex(0);
			}
			focusedShape = null;
		}
		render();
	}
	function changeShapes(geo){//geo: 当前类型
		switch (geo) {
			case 0:
				// 正方形
				currentShapeType = 0;
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
				break;
			case 1:
				//圆柱
				currentShapeType = 1;
				currentObj = new THREE.CylinderBufferGeometry( 25, 25, 50, 32 ); //CylinderGeometry(radiusTop : 浮点类型, radiusBottom : 浮点类型, height : 浮点类型, radialSegments : 整数类型, heightSegments : 整数类型, openEnded : 布尔类型, thetaStart : 浮点类型, thetaLength : 浮点类型)
				break;
			case 2:
				// 圆锥形
				currentShapeType = 2;
				currentObj = new THREE.ConeBufferGeometry( 25, 50, 32 ); //ConeBufferGeometry(radius : Float, height : Float, radialSegments : Integer, heightSegments : Integer, openEnded : Boolean, thetaStart : Float, thetaLength : Float)
				break;
			case 3:
				// 球形
				currentShapeType = 3;
				currentObj =  new THREE.SphereBufferGeometry( 25, 25, 32);//SphereBufferGeometry(radius : Float, widthSegments : Integer, heightSegments : Integer, phiStart : Float, phiLength : Float, thetaStart : Float, thetaLength : Float)
				break;
			case 4:
				// 环形
				currentShapeType = 4;
				currentObj =  new THREE.TorusGeometry(20, 5, 16, 100 );//TorusGeometry(radius : Float, tube : Float, radialSegments : Integer, tubularSegments : Integer, arc : Float)
				break;
			default:
				// 正方形
				currentObj = new THREE.BoxBufferGeometry( 50, 50, 50 );
		}

		changeMouseHelper(currentColorFlag);
		currentObjMesh = new THREE.Mesh(currentObj,currentObjMaterial);
		// scene.add( currentObjMesh );
	}
	function changeCurrentColor(color){
		if(color == 0) {
			currentColor = 0xFFFFFF;
			currentColorFlag = 0;
			currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xFFFFFF } );
			changeMouseHelper(0)
		}
		else{
			currentColorFlag = 1;
			currentColor=0xf2f545
			currentObjMaterial = new THREE.MeshLambertMaterial( { color: 0xf2f545 } );
			changeMouseHelper(1)
		}
	}
	function changeMouseHelper(type){ //type 0: 颜色改为白色 1：颜色改为黄色
		if (type == 0) {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xffffff, opacity: 1, transparent: true } );
		} else {
			mouseHelperMaterial = new THREE.MeshBasicMaterial( { color: 0xf2f545, opacity: 1, transparent: true } );
		}
		clearCache( mouseHelper );
		scene.remove( mouseHelper );
		mouseHelper = new THREE.Mesh( currentObj, mouseHelperMaterial );
		mouseHelper.name = "mouseHelper";
		scene.add( mouseHelper );
	}
	function selectShapeModule(){
		if(params.selectShape) {
			console.log( "remove" );
			clearCache( mouseHelper );
			scene.remove( mouseHelper );
			camera.position.set( 500, 800, 1000 );
			camera.lookAt( 0, 0, 0 );
			render();
		}
		else{
			transformControl.detach( transformControl.object ); //隐藏控制控件
			selectedShapeFlag = false;
			scene.add( mouseHelper );
		}
	}
	function removeAllShapes(){
		shapesObj.forEach( function ( d ) {
			clearCache(d);
			scene.remove( d );
			for(var i in objects){
				if(objects[i].uuid == d.uuid) {
					objects.splice( i, 1 ); //remove element that index is i in array decals
				}
			}
		} );
		shapesObj = [];
	}
	function initGUI(){

		var gui = new dat.GUI();
		/*gui.add( params, 'SUBMIT' );
		gui.add( params, 'Geometry', geometries ).onChange( function () {
			// changeShapes(geometries[ params.Geometry ]);
			changeShapes();
		} );
		gui.add( params, 'color', shapeColor ).name('Color').onChange( function () {
			changeCurrentColor(shapeColor[params.color]);
		} );*/
		var shapess = gui.addFolder("Shapes");
		shapess.add(params,'Cube');
		shapess.add(params,'Cylinder');
		shapess.add(params,'Cone');
		shapess.add(params,'Ball');
		shapess.add(params,'Doughnut');
		shapess.open();
		var colorss = gui.addFolder("Color");
		colorss.add(params,'white');
		colorss.add(params,'yellow');
		colorss.open();
		gui.add(params,'selectShape').onChange(function(){
			selectShapeModule();
		});
		gui.add(params,'clear').name("Remove All");
		gui.add( params, 'SUBMIT' ).name("exportSTL");
		gui.add( params, 'SUBMITGLTFE' ).name("exportGLTF");

	}

	var hiding;

	function delayHideTransform() {

		cancelHideTransform();
		hideTransform();

	}

	function hideTransform() {

		hiding = setTimeout( function () {

			transformControl.detach( transformControl.object );

		}, 2500 );

	}

	function cancelHideTransform() {

		if ( hiding ) clearTimeout( hiding );

	}
	function updateShapePosition() {

		console.log("updateShapePosition")
	}

	// 导出相关
	function exportASCII() {
		scene.remove(transformControl);
		scene.remove(mouseHelper);
		exporter = new THREE.STLExporter(); //导出工具  exporter tool
		var result = exporter.parse( scene );
		var date= Date.parse(new Date());
		saveString( result, date+'.stl' );

		scene.add(transformControl);
		scene.add(mouseHelper);
	}
	var link = document.createElement( 'a' );
	link.style.display = 'none';
	document.body.appendChild( link );

	function save( blob, filename ) {

		link.href = URL.createObjectURL( blob );
		link.download = filename;
		link.click();

	}
	function saveString( text, filename ) {

		save( new Blob( [ text ], { type: 'text/plain' } ), filename );

	}
	function exportGLTF(  ) {
		scene.remove(transformControl);
		scene.remove(mouseHelper);
		var input = scene;
		var gltfExporter = new THREE.GLTFExporter();

		var options = {
			trs: false,
			onlyVisible: true,
			truncateDrawRange: true,
			binary: false,
			forcePowerOfTwoTextures: false,
			maxTextureSize: 4096
		};
		gltfExporter.parse( input, function ( result ) {
				var output = JSON.stringify( result, null, 2 );
				console.log( output );
				saveString( output, 'scene.gltf' );
		}, options );
		scene.add(transformControl);
		scene.add(mouseHelper);
	}
	/**
	 * 清空当前obj对象的缓存
	 * @param mesh  mesh对象
	 * */
	function clearCache(currentMesh) {
		currentMesh.geometry.dispose();
		currentMesh.material.dispose();
	}
</script>

</body>
</html>
